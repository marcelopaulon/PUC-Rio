package map;

import pathfinding.Node;
import mapcell.MapCell;

/**
 * The game's map
 */
public class GameMap {
	
	/**
	 * Matrix representation of the game's map
	 */
	private char[][] mapData;
	
	/**
	 * Matrix representation of AStar's chosen path
	 * <p>The cells that represent the path are marked with an X
	 * (see AStar.java -> line 93)</p>  
	 */
	public char[][] pathData;
	
	/**
	 * <p><b>nRows</b> - Number of rows in the matrix</p>
	 * <p><b>nColumns</b> - Number of columns in the matrix</p>
	 */
	private int nRows, nColumns;
	
	/**
	 * OVERALL: revise if this is correct
	 * <p><b>startX</b> - Start Tile's Column of the map</p>
	 * <p><b>startY</b> - Start Tile's Row of the map</p>
	 * <p><b>endX</b> - End Tile's Column of the map</p>
	 * <p><b>endY</b> - End Tile's Row of the map</p>
	 */	
	public int startX, startY, endX, endY;

	/**
	 * GameMap constructor
	 * <p><b>GameMap:</b> Matrix representing the game map</p>
	 * @param data Matrix used to generate the map, following specifications from the assignment
	 */
	public GameMap(char[][] data) {
		mapData = data;

		nRows = mapData.length;
		nColumns = mapData[0].length;
		
		pathData = new char[nRows][nColumns];
		
		for(int i = 0; i < nRows; i++)
		{
			for(int j = 0; j < nColumns; j++)
			{
				if(mapData[i][j] == MapCell.Cells.START.asChar())
				{
					startX = j + 1;
					startY = i + 1;
				}
				else if(mapData[i][j] == MapCell.Cells.END.asChar())
				{
					endX = j + 1;
					endY = i + 1;
				}
			}
		}
	}
	
	/**
	 * Clears the path generated by AStar
	 */
	public void clearPath()
	{
		nRows = mapData.length;
		nColumns = mapData[0].length;
		
		pathData = new char[nRows][nColumns];
		
		for(int i = 0; i < nRows; i++)
		{
			for(int j = 0; j < nColumns; j++)
			{
				pathData[i][j] = '\0';
			}
		}
	}

	/**
	 * Takes the number of rows from GameMap
	 * @return number of rows from GameMap
	 */
	public int getNRows() {
		return nRows;
	}

	/**
	 * Takes the number of columns from GameMap
	 * @return number of columns from GameMap
	 */
	public int getNColumns() {
		return nColumns;
	}

	/**
	 * Searches neighbor nodes from a GameMap cell
	 * @param row Y coordinate of the cell whose neighbors will be searched
	 * @param column X coordinate of the cell whose neighbors will be searched
	 * @return Node vectors containing the cell's neighbors' coordinates
	 */
	public Node[] getNeighbors(int row, int column) {
		Node[] neighbors = new Node[4];

		// North
		if (row - 1 > 0) {
			neighbors[0] = getValue(row - 1, column);
		}

		// South
		if (row + 1 <= nRows) {
			neighbors[1] = getValue(row + 1, column);
		}

		// West
		if (column - 1 > 0) {
			neighbors[2] = getValue(row, column - 1);
		}

		// East
		if (column + 1 <= nColumns) {
			neighbors[3] = getValue(row, column + 1);
		}
		
		return neighbors;
	}

	/**
	 * Modifies the type of terrain from a certain GameMap cell
	 * @param row Y coordinate of the cell to be modified
	 * @param column X coordinate of the cell to be modified
	 * @param value Cell's new value
	 * @return true
	 */
	public boolean setValue(int row, int column, MapCell.Cells value) {
		mapData[row - 1][column - 1] = value.asChar();
		return true;
	}

	/**
	 * Indicates the type of terrain from a certain GameMap cell
	 * @param row Cell's Y coordinate
	 * @param column Cell's X coordinate
	 * @return Node indicating X and Y coordinates and the cell's type of terrain or <b>null</b> in case the cell
	 * searched for is outside the matrix.
	 */
	public Node getValue(int row, int column) {
		if (mapData.length < row || mapData[0].length < column)
			return null;

		char tileType = mapData[row - 1][column - 1];
		MapCell.Cells cellType = null;
		
		if (tileType == MapCell.Cells.MOUNTAIN.asChar()) {
			cellType = MapCell.Cells.MOUNTAIN;
		} else if (tileType == MapCell.Cells.PLAIN.asChar()) {
			cellType = MapCell.Cells.PLAIN;
		} else if (tileType == MapCell.Cells.ROCK.asChar()) {
			cellType = MapCell.Cells.ROCK;
		} else if (tileType == MapCell.Cells.ENEMYAA.asChar()) {
			cellType = MapCell.Cells.ENEMYAA;
		} else if (MapCell.enemyBases.containsKey(tileType)) {
			cellType = MapCell.Cells.ENEMYBASE;
			return new Node(column, row, cellType, MapCell.enemyBases.get(tileType));
		} else if (tileType == MapCell.Cells.START.asChar()) {
			cellType = MapCell.Cells.START;
		} else if (tileType == MapCell.Cells.END.asChar()) {
			cellType = MapCell.Cells.END;
		}
		
		return new Node(column, row, cellType);
	}
}
